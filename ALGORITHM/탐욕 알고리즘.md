1. 반복과 재귀
    - 반복은 수행하는 작업이 완료될 때까지 계속 반복
        - 루프 (for, while 구조)
        - 코드를 n번 반복시킬 수 있다. 
    - 재귀는 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법
        - 하나의 큰 문제를 해결하기 쉬운 더 작은 문제로 쪼개고 결과들을 결합
        - 재귀호출은 n중 반복문을 만들 수 있다. 가독성이 좋다.
        - 기저조건(종료조건): 언제까지 반복을 할 것인가. 무한 재귀호출을 막는 것부터 시작
            - 조건 만족하면 return
        - 1.기저조건 / 2.다음 재귀 호출 전 / 3.재귀 호출(현재 값에 무슨 수식을 적용해서 넘겨줄지) / 4.호출하고 돌아왔을 때
    - 함수 호출할 때 int타입 객체를 전달하면 값만 복사가 된다.
        - global, 리스트(주소값 전달), return 등을 사용하면 원본의 값도 바뀜

2. 순열
    - 서로 다른 N개에서 R개를 중복없이, 순서를 고려하여 나열하는 것
    - 중복순열 구현
        - 재귀호출을 할 때마다 이동 경로를 흔적으로 남긴다. 가장 마지막 레벨에 도달했을 때(기저조건을 만족할 때) 이동경로를 출력한다.
    - 순열 구현
        - 중복순열 코드 작성하고, 중복을 제거하는 코드를 추가
        - 전역 리스트를 사용하면 이미 선택했던 숫자인지 구분 가능
            - used배열 또는 visited 배열(DFS, BFS에 사용되는 것과 같음)
            - 숫자 사용 여부를 저장할 배열
        - in을 사용할 경우 시간초과 발생할수도

3. 완전 탐색(Brute-Force, 부르트 포스 알고리즘)
    - 모든 가능한 경우를 모두 시도해서 정답을 찾아내는 알고리즘
    - 다른 숫자와 서로 영향이 없는 독립적인 문제 -> 규칙x 미리 계산x -> 완전탐색
    - 완전탐색 도중 백트래킹(가지치기 return)

4. 부분 집합
    - 집합에 포함된 원소들을 선택, 공집합도 포함
    - 구현 방법
        1. 재귀호출을 이용한 완전탐색
        2. Binary Counting: 2진수 & 비트연산을 이용

5. 조합
    - 서로 다른 n개의 원소 중 r개를 순서 없이 골라낸 것

6. 그리디(Greedy)
    - 결정이 필요할 때, 현재 기준으로 가장 좋아보이는 선택지로 결정하여 답을 얻는 알고리즘 
    - 각 단계의 선택이 이후 선택에 영향을 주지 않아야함
        - 내가 정한 규칙이 정답이다, 수식으로 표현가능한가 반례는 없는가 증명해야함
        - 증명하지 않는 경우 코테에서 테케 1개만 틀리는 경우 종종 생긴다 -> 이 경우 그리디가 아닌 문제를 그리디로 푼 것이라 해결못한다
    - 단계:
        1. 각 단계에서 최적해를 찾는다
        2. 단계의 결과들을 합하는 방법을 찾는다
        3. 각 단계의 합 == 전체 문제의 합이라는 것을 증명한다