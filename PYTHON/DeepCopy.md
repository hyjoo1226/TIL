- 얕은 복사(Shallow copy)
    - 주소값을 복사하여 새로운 인스턴트를 생성하지 않아 같은 메모리를 가리킨다.
    - 슬라이싱, '=' 대입 연산자를 통해 할당, copy 메소드(import copy)
- 깊은 복사(Deep copy)
    - 데이터 자체를 통째로 복사하여 두 객체는 서로 완전히 독립적인 메모리를 차지한다.
    - copy.deepcopy 메소드(import copy)
    - arr[:] for arr in x
    ```
    backup_a = []
    for arr in a:
    backup_a.append(arr[:])
    ```
arr[:]는 새로운 주소값을 만든다. 빈 리스트 backup_a의 각 인덱스마다 새로운 주소값을 가진 arr을 추가한다. -> 이중배열이어도 깊은 복사 가능

```
# 할당  - 복사x. 객체참조(주소)가 복사된다(a와b는 같은주소)
 # 가변데이터
a = [1, 2, 3, 4]
b = a
b[0] = 100

print(a)    # [100, 2, 3, 4]
print(b)    # [100, 2, 3, 4]

 # 불변데이터
a = 20
b = a
b = 10

print(a)    # 20    리스트와 달리 불변하는 자료형이므로 b는 새롭게 재할당
print(b)    # 10

# 얕은 복사
 # 가변데이터
a = [1, 2, 3]
b = a[:]
c = a.copy()

b[0] = 100
c[0] = 999
print(a)    # [1, 2, 3]
print(b)    # [100, 2, 3]
print(c)    # [999, 2, 3]

# 얕은 복사의 한계      중첩 리스트의 주소는 같아짐
a = [1, 2, [3, 4, 5]]
b = a[:]

b[0] = 999
b[2][1] = 100
print(a)    # [1, 2, [3, 100, 5]]
print(b)    # [999, 2, [3, 100, 5]]

# 깊은 복사
import copy

a = [1, 2, [3, 4, 5]]
b = copy.deepcopy(a)

b[0] = 999
b[2][1] = 100
print(a)    # [1, 2, [3, 4, 5]]
print(b)    # [999, 2, [3, 100, 5]]
```